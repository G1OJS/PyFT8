import numpy as np

def bits_to_int(bits):
    """bits is LSB-first: sum(bits[i] << i)."""
    n = 0
    for i, b in enumerate(bits):
        n |= (int(b) & 1) << i
    return n

def int_to_bits(n, width):
    """Return [b0, b1, ..., b(width-1)] where b0 is LSB of n."""
    return [(n >> i) & 1 for i in range(width)]

def ldpc_encode(msg_crc: int) -> int:
    generator_matrix_rows = [
        "8329ce11bf31eaf509f27fc",
        "761c264e25c259335493132",
        "dc265902fb277c6410a1bdc",
        "1b3f417858cd2dd33ec7f62",
        "09fda4fee04195fd034783a",
        "077cccc11b8873ed5c3d48a",
        "29b62afe3ca036f4fe1a9da",
        "6054faf5f35d96d3b0c8c3e",
        "e20798e4310eed27884ae90",
        "775c9c08e80e26ddae56318",
        "b0b811028c2bf997213487c",
        "18a0c9231fc60adf5c5ea32",
        "76471e8302a0721e01b12b8",
        "ffbccb80ca8341fafb47b2e",
        "66a72a158f9325a2bf67170",
        "c4243689fe85b1c51363a18",
        "0dff739414d1a1b34b1c270",
        "15b48830636c8b99894972e",
        "29a89c0d3de81d665489b0e",
        "4f126f37fa51cbe61bd6b94",
        "99c47239d0d97d3c84e0940",
        "1919b75119765621bb4f1e8",
        "09db12d731faee0b86df6b8",
        "488fc33df43fbdeea4eafb4",
        "827423ee40b675f756eb5fe",
        "abe197c484cb74757144a9a",
        "2b500e4bc0ec5a6d2bdbdd0",
        "c474aa53d70218761669360",
        "8eba1a13db3390bd6718cec",
        "753844673a27782cc42012e",
        "06ff83a145c37035a5c1268",
        "3b37417858cc2dd33ec3f62",
        "9a4a5a28ee17ca9c324842c",
        "bc29f465309c977e89610a4",
        "2663ae6ddf8b5ce2bb29488",
        "46f231efe457034c1814418",
        "3fb2ce85abe9b0c72e06fbe",
        "de87481f282c153971a0a2e",
        "fcd7ccf23c69fa99bba1412",
        "f0261447e9490ca8e474cec",
        "4410115818196f95cdd7012",
        "088fc31df4bfbde2a4eafb4",
        "b8fef1b6307729fb0a078c0",
        "5afea7acccb77bbc9d99a90",
        "49a7016ac653f65ecdc9076",
        "1944d085be4e7da8d6cc7d0",
        "251f62adc4032f0ee714002",
        "56471f8702a0721e00b12b8",
        "2b8e4923f2dd51e2d537fa0",
        "6b550a40a66f4755de95c26",
        "a18ad28d4e27fe92a4f6c84",
        "10c2e586388cb82a3d80758",
        "ef34a41817ee02133db2eb0",
        "7e9c0c54325a9c15836e000",
        "3693e572d1fde4cdf079e86",
        "bfb2cec5abe1b0c72e07fbe",
        "7ee18230c583cccc57d4b08",
        "a066cb2fedafc9f52664126",
        "bb23725abc47cc5f4cc4cd2",
        "ded9dba3bee40c59b5609b4",
        "d9a7016ac653e6decdc9036",
        "9ad46aed5f707f280ab5fc4",
        "e5921c77822587316d7d3c2",
        "4f14da8242a8b86dca73352",
        "8b8b507ad467d4441df770e",
        "22831c9cf1169467ad04b68",
        "213b838fe2ae54c38ee7180",
        "5d926b6dd71f085181a4e12",
        "66ab79d4b29ee6e69509e56",
        "958148682d748a38dd68baa",
        "b8ce020cf069c32a723ab14",
        "f4331d6d461607e95752746",
        "6da23ba424b9596133cf9c8",
        "a636bcbc7b30c5fbeae67fe",
        "5cb0d86a07df654a9089a20",
        "f11f106848780fc9ecdd80a",
        "1fbb5364fb8d2c9d730d5ba",
        "fcb86bc70a50c9d02a5d034",
        "a534433029eac15f322e34c",
        "c989d9c7c3d3b8c55d75130",
        "7bb38b2f0186d46643ae962",
        "2644ebadeb44b9467d1f42c",
        "608cc857594bfbb55d69600"
    ]

    kGEN = np.array([int(row,16)>>1 for row in generator_matrix_rows])
    msg_crc = int(msg_crc)
    parity_bits = 0
    for row in map(int, kGEN):
        bit = bin(msg_crc & row).count("1") & 1
        parity_bits = (parity_bits << 1) | bit
    return (msg_crc << 83) | parity_bits

def safe_atanh(x, eps=1e-12):
    x = np.clip(x, -1 + eps, 1 - eps)
    return np.arctanh(x)

def decode_ldpc(llr,ax):
    """
    Decode the codeword using LDPC with a bit-level decoder.
    """
    # Constants
    kNCW = 3
    kNM = np.array([[3,30,58,90,91,95,152],[4,31,59,92,114,145,0],[5,23,60,93,121,150,0],[6,32,61,94,95,142,0],[7,24,62,82,92,95,147],[5,31,63,96,125,137,0],[4,33,64,77,97,106,153],[8,34,65,98,138,145,0],[9,35,66,99,106,125,0],[10,36,66,86,100,138,157],[11,37,67,101,104,154,0],[12,38,68,102,148,161,0],[7,39,69,81,103,113,144],[13,40,70,87,101,122,155],[14,41,58,105,122,158,0],[0,32,71,105,106,156,0],[15,42,72,107,140,159,0],[16,36,73,80,108,130,153],[10,43,74,109,120,165,0],[44,54,63,110,129,160,172],[7,45,70,111,118,165,0],[17,35,75,88,112,113,142],[18,37,76,103,115,162,0],[19,46,69,91,137,164,0],[1,47,73,112,127,159,0],[20,44,77,82,116,120,150],[21,46,57,117,126,163,0],[15,38,61,111,133,157,0],[22,42,78,119,130,144,0],[18,34,58,72,109,124,160],[19,35,62,93,135,160,0],[13,30,78,97,131,163,0],[2,43,79,123,126,168,0],[18,45,80,116,134,166,0],[6,48,57,89,99,104,167],[11,49,60,117,118,143,0],[12,50,63,113,117,156,0],[23,51,75,128,147,148,0],[24,52,68,89,100,129,155],[19,45,64,79,119,139,169],[20,53,76,99,139,170,0],[34,81,132,141,170,173,0],[13,29,82,112,124,169,0],[3,28,67,119,133,172,0],[0,3,51,56,85,135,151],[25,50,55,90,121,136,167],[51,83,109,114,144,167,0],[6,49,80,98,131,172,0],[22,54,66,94,171,173,0],[25,40,76,108,140,147,0],[1,26,40,60,61,114,132],[26,39,55,123,124,125,0],[17,48,54,123,140,166,0],[5,32,84,107,115,155,0],[27,47,69,84,104,128,157],[8,53,62,130,146,154,0],[21,52,67,108,120,173,0],[2,12,47,77,94,122,0],[30,68,132,149,154,168,0],[11,42,65,88,96,134,158],[4,38,74,101,135,166,0],[1,53,85,100,134,163,0],[14,55,86,107,118,170,0],[9,43,81,90,110,143,148],[22,33,70,93,126,152,0],[10,48,87,91,141,156,0],[28,33,86,96,146,161,0],[29,49,59,85,136,141,161],[9,52,65,83,111,127,164],[21,56,84,92,139,158,0],[27,31,71,102,131,165,0],[27,28,83,87,116,142,149],[0,25,44,79,127,146,0],[16,26,88,102,115,152,0],[50,56,97,162,164,171,0],[20,36,72,137,151,168,0],[15,46,75,129,136,153,0],[2,23,29,71,103,138,0],[8,39,89,105,133,150,0],[14,57,59,73,110,149,162],[17,41,78,143,145,151,0],[24,37,64,98,121,159,0],[16,41,74,128,169,171,0]], dtype=int)
    kMN = np.array([[15,44,72],[24,50,61],[32,57,77],[0,43,44],[1,6,60],[2,5,53],[3,34,47],[4,12,20],[7,55,78],[8,63,68],[9,18,65],[10,35,59],[11,36,57],[13,31,42],[14,62,79],[16,27,76],[17,73,82],[21,52,80],[22,29,33],[23,30,39],[25,40,75],[26,56,69],[28,48,64],[2,37,77],[4,38,81],[45,49,72],[50,51,73],[54,70,71],[43,66,71],[42,67,77],[0,31,58],[1,5,70],[3,15,53],[6,64,66],[7,29,41],[8,21,30],[9,17,75],[10,22,81],[11,27,60],[12,51,78],[13,49,50],[14,80,82],[16,28,59],[18,32,63],[19,25,72],[20,33,39],[23,26,76],[24,54,57],[34,52,65],[35,47,67],[36,45,74],[37,44,46],[38,56,68],[40,55,61],[19,48,52],[45,51,62],[44,69,74],[26,34,79],[0,14,29],[1,67,79],[2,35,50],[3,27,50],[4,30,55],[5,19,36],[6,39,81],[7,59,68],[8,9,48],[10,43,56],[11,38,58],[12,23,54],[13,20,64],[15,70,77],[16,29,75],[17,24,79],[18,60,82],[21,37,76],[22,40,49],[6,25,57],[28,31,80],[32,39,72],[17,33,47],[12,41,63],[4,25,42],[46,68,71],[53,54,69],[44,61,67],[9,62,66],[13,65,71],[21,59,73],[34,38,78],[0,45,63],[0,23,65],[1,4,69],[2,30,64],[3,48,57],[0,3,4],[5,59,66],[6,31,74],[7,47,81],[8,34,40],[9,38,61],[10,13,60],[11,70,73],[12,22,77],[10,34,54],[14,15,78],[6,8,15],[16,53,62],[17,49,56],[18,29,46],[19,63,79],[20,27,68],[21,24,42],[12,21,36],[1,46,50],[22,53,73],[25,33,71],[26,35,36],[20,35,62],[28,39,43],[18,25,56],[2,45,81],[13,14,57],[32,51,52],[29,42,51],[5,8,51],[26,32,64],[24,68,72],[37,54,82],[19,38,76],[17,28,55],[31,47,70],[41,50,58],[27,43,78],[33,59,61],[30,44,60],[45,67,76],[5,23,75],[7,9,77],[39,40,69],[16,49,52],[41,65,67],[3,21,71],[35,63,80],[12,28,46],[1,7,80],[55,66,72],[4,37,49],[11,37,63],[58,71,79],[2,25,78],[44,75,80],[0,64,73],[6,17,76],[10,55,58],[13,38,53],[15,36,65],[9,27,54],[14,59,69],[16,24,81],[19,29,30],[11,66,67],[22,74,79],[26,31,61],[23,68,74],[18,20,70],[33,52,60],[34,45,46],[32,58,75],[39,42,82],[40,41,62],[48,74,82],[19,43,47],[41,48,56]], dtype=int)
    kNRW = np.array([7, 6, 6, 6, 7, 6, 7, 6, 6, 7, 6, 6, 7, 7, 6, 6, 6, 7, 6, 7, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 7, 7, 6, 6, 6, 6, 7, 7, 6, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 6, 7, 6, 6, 6, 7, 6, 6, 6, 7, 7, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6], dtype=int)
    kN = 174  # Number of variables (message length)
    kM = 83   # Number of check nodes

    kNM = np.where(kNM == 0, -1, kNM)

    maxiterations = 50
    llr = np.asarray(llr, dtype=float)
    toc = np.zeros((7, kM))          # message -> check messages
    tanhtoc = np.zeros((7, kM))
    tov = np.zeros((kNCW, kN))        # check->message messages

    info = []
    zn = np.copy(llr)
    for it in range(maxiterations + 1):
        for i in range(kN):
            zn[i] += 1000*sum(tov[:,i])

      #  print(','.join([f"{l:.0f}" for l in zn]))
        ax.plot(zn)

        cw = (zn > 0).astype(int)
        # syndrome
        ncheck = 0
        synd = np.zeros(kM, dtype=int)
        for chk in range(kM):
            # sum variable nodes participating in this check
            # kNM stores 1-based variable indices in each row; use first kNRW[chk] entries
            # note that synd doesn't *need* to be an array unless it's used for debugging
            vars_idx = kNM[chk, :kNRW[chk]]
            synd[chk] = int(np.sum(cw[vars_idx]) % 2)
            if synd[chk] != 0:
                ncheck += 1

        info.append(ncheck)
        print(ncheck)

        # success
        if ncheck == 0:
            message91 = cw.tolist()
            if(sum(message91)>0):
                #print(f"Success: {info}")
                return message91

        # compute toc = messages from variable node -> check node
        # For each check node j, for each connected variable i
        for j in range(kM):
            for i_local in range(kNRW[j]):         # 0 .. kNRW[j]-1
                ibj = int(kNM[j, i_local])         # variable node index (0-based)
                toc[i_local, j] = zn[ibj]
                # subtract messages from checks (tov) that correspond to other checks connected to variable ibj
                # kMN[ibj, :] lists checks (1-based) that connect to variable ibj
                for kk in range(kNCW):
                    chknum = kMN[ibj, kk]
                    if chknum == 0:
                        # if kMN uses 0 as sentinel for "no more checks", skip
                        continue
                    if chknum == (j + 1):
                        # skip the current check (do not subtract its message)
                        continue
                    tov_idx = kk
                    tov_val = tov[tov_idx, ibj]
                    toc[i_local, j] -= tov_val

        # tanh of half negative (matching original)
        for j in range(kM):
            tanhtoc[:kNRW[j], j] = np.tanh(-toc[:kNRW[j], j] / 2.0)

        # compute tov (check->variable messages)
        # for each variable node j, it connects to kNCW checks (kMN[j, :])
        for var in range(kN):
            # iterate check-positions kk for this variable
            for kk in range(kNCW):
                chknum = kMN[var, kk]
                if chknum == 0:
                    # sentinel / unused
                    tov[kk, var] = 0.0
                    continue
                ichk = int(chknum)   # check index 0-based
                # build mask over the neighbours of check ichk excluding current variable 'var'
                neigh_count = kNRW[ichk]
                neigh_vars = kNM[ichk, :neigh_count]  
                # mask which entries are not equal to this var index
                mask = (neigh_vars != var)
                if mask.sum() == 0:
                    # no other neighbours => product is 1? set small value
                    Tmn = 0.0
                else:
                    # product of tanh values for other edges
                    tvals = tanhtoc[:neigh_count, ichk][mask]
                    # product; make sure to handle empty product
                    Tmn = np.prod(tvals) if tvals.size > 0 else 0.0

                # inverse tanh (clipped)
                y = safe_atanh(-Tmn)
                alpha = 1   # 0 < alpha <= 1 ; try 0.3..0.9. lower = more damping
                new_val = 2.0 * safe_atanh(-Tmn)
                tov[kk, var] = alpha * new_val + (1 - alpha) * tov[kk, var]

    # failed to decode
    #print(f"Failure: {info}")
    return []


import matplotlib.pyplot as plt
fig, ax = plt.subplots()

def add_noise_to_llr(llr, snr_db):
    snr_linear = 10 ** (snr_db / 10)
    noise_std = np.std(llr) / np.sqrt(snr_linear)
    noise = np.random.normal(0, noise_std, size=llr.shape)
    llr_noisy = llr + noise
    return llr_noisy


# 91 bits for message 'VK1ABC VK3JPK QF22' (including crc)
bits91_int = 0b1110000111111100010100110101011100010000001111010000111100011100101000101000100111100110010
print(f"Original message:\n{bits91_int:b}")
# Encode the message (add parity)
bits174_int = ldpc_encode(bits91_int)
print(f"With parity:\n{bits174_int:b}")

#simulate LLRs
bits174_lst = int_to_bits(bits174_int,174)
llr = 200000 * np.array(bits174_lst) - 100000  # LLRs for each bit (encoded message)
llr = llr[::-1]
ax.plot(llr)
llr = add_noise_to_llr(llr, 3)

#llr = [168264.8125, 168263.609375, 168264.609375, -213171.40625, -213172.25, -213172.46875, -171861.40625, 171850.109375, 171850.109375, 247488.90625, 247488.875, 247489.234375, 178312.328125, 178310.859375, -178315.453125, -240442.484375, -240446.125, 240442.484375, -284924.09375, 284913.40625, -284892.21875, -231327.5625, 231327.625, 231329.484375, -284218.75, 284218.65625, -284219.875, 310894.5625, -310894.5625, 310897.53125, 293391.40625, 293391.375, -293394.375, -211995.3125, -211993.015625, 211993.015625, -346274.71875, -346274.6875, -346284.0, -284695.5625, -284695.5625, -284725.5625, 267244.53125, 267253.65625, 267244.78125, 213010.984375, -213019.46875, 213011.0, -208873.921875, -208873.953125, -208873.921875, -154840.578125, 154845.8125, 154846.28125, 145890.640625, 145898.734375, -145892.421875, -133038.546875, -133038.578125, 133044.546875, 184216.0, 184212.078125, -184216.25, -238033.09375, 238026.484375, -238026.546875, 135219.515625, -135218.203125, -135218.015625, -126881.1640625, 126881.1640625, -126881.4296875, 171710.640625, -171711.359375, -171710.375, -184266.5625, 184232.484375, -184232.484375, -132071.4375, 132063.0, 132063.0, 189981.1875, 189981.484375, -189981.171875, -120264.765625, 120261.5859375, 120265.7890625, -174743.078125, -174743.078125, 174753.890625, -204370.25, -204370.21875, 204371.5625, 280698.75, -280702.53125, 280698.71875, -292128.875, 292104.9375, -292104.9375, 234222.53125, 234222.53125, 234222.53125, 212478.203125, 212479.453125, -212480.09375, 112607.3828125, -112607.3984375, 112607.4296875, 131780.765625, 131780.53125, -131780.953125, -151043.3125, -151040.59375, -151041.671875, -190148.21875, 190148.21875, 190148.21875, 325452.65625, 325450.25, 325450.1875, 279530.8125, 279519.40625, 279519.40625, -160533.921875, 160528.828125, -160529.4375, 241812.828125, -241819.203125, -241818.3125, 118475.6484375, -118475.46875, 118477.171875, 172311.09375, 172311.09375, -172312.21875, -134389.96875, 134393.953125, 134389.953125, -101325.9765625, 101313.4375, 101320.4609375, 235440.734375, -235450.8125, -235450.796875, 113075.703125, 113074.3046875, -113074.59375, -191349.484375, 191349.515625, -191355.03125, -246841.234375, -246834.6875, -246841.859375, -227833.171875, -227829.5625, -227832.078125, -271556.0, -271554.6875, -271574.71875, -208866.421875, 208872.296875, 208873.859375, 277496.84375, -277492.03125, -277473.75, -241047.84375, 241049.578125, -241047.84375, -216455.3125, -216455.4375, -216455.3125, -119437.4921875, -119430.40625, 119432.3203125]
#print(','.join([f"{l:.0f}" for l in llr]))

# Decode the message using LDPC
decoded_message = bits_to_int(decode_ldpc(llr, ax)[::-1])

# Print the results
print(f"Decoded bits174:\n{decoded_message:b}")

plt.show()
